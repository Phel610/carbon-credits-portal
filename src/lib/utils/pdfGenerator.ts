import jsPDF from 'jspdf';

interface AICommentary {
  executiveSummary: string;
  riskAssessment: string;
  scenarioCommentary: string;
  investorHighlights: string;
}

interface ModelData {
  name: string;
  project_name?: string;
  country?: string;
  start_year: number;
  end_year: number;
}

interface ScenarioData {
  scenario_name: string;
  is_base_case: boolean;
  notes?: string;
  probability?: number;
  metrics: any;
  changes: Array<{ 
    key: string;
    name: string;
    baseValue: any;
    newValue: any;
    change: number;
  }>;
}

export const generatePDF = async (
  financialData: any,
  modelData: ModelData,
  reportType: 'standard' | 'ai-assisted',
  modelInputs?: any,
  scenarios?: ScenarioData[],
  comprehensiveMetrics?: any,
  aiCommentary?: AICommentary
): Promise<void> => {
  const pdf = new jsPDF('p', 'mm', 'a4');
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 15;
  const contentWidth = pageWidth - 2 * margin;
  
  let yPosition = margin;
  let currentPage = 1;

  // Helper functions
  const checkPageBreak = (requiredHeight: number) => {
    if (yPosition + requiredHeight > pageHeight - margin - 10) {
      addPageFooter();
      pdf.addPage();
      currentPage++;
      yPosition = margin;
      return true;
    }
    return false;
  };

  const addPageFooter = () => {
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(100, 100, 100);
    pdf.text('Generated by Financial Platform', margin, pageHeight - 7);
    pdf.text(`Page ${currentPage}`, pageWidth - margin, pageHeight - 7, { align: 'right' });
    pdf.setTextColor(0, 0, 0);
  };

  const addText = (text: string, x: number, y: number, maxWidth: number, fontSize: number = 10) => {
    pdf.setFontSize(fontSize);
    const lines = pdf.splitTextToSize(text, maxWidth);
    pdf.text(lines, x, y);
    return lines.length * (fontSize * 0.4);
  };

  const addSectionTitle = (title: string) => {
    checkPageBreak(20);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text(title, margin, yPosition);
    yPosition += 8;
    pdf.setLineWidth(0.5);
    pdf.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += 8;
  };

  const formatCurrency = (value: number): string => {
    return `$${Math.abs(value).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
  };

  const formatPercent = (value: number): string => {
    return `${(value * 100).toFixed(1)}%`;
  };

  const VARIABLE_FORMATS: Record<string, 'currency' | 'percentage' | 'number'> = {
    'credits_generated': 'number',
    'price_per_credit': 'currency',
    'cogs_rate': 'percentage',
    'staff_costs': 'currency',
    'mrv_costs': 'currency',
    'pdd_costs': 'currency',
    'feasibility_costs': 'currency',
    'capex': 'currency',
    'depreciation': 'currency',
    'discount_rate': 'percentage',
    'interest_rate': 'percentage',
    'income_tax_rate': 'percentage',
    'ar_rate': 'percentage',
    'ap_rate': 'percentage',
    'equity_injection': 'currency',
    'debt_draw': 'currency',
    'purchase_amount': 'currency',
    'purchase_share': 'percentage',
    'debt_duration_years': 'number',
    'issuance_flag': 'number',
  };

  const formatVariableValue = (key: string, value: number): string => {
    const format = VARIABLE_FORMATS[key] || 'number';
    
    if (format === 'currency') {
      return `$${Math.round(value).toLocaleString()}`;
    }
    if (format === 'percentage') {
      return `${value.toFixed(1)}%`;
    }
    return Math.round(value).toLocaleString();
  };

  const addDataTable = (headers: string[], rows: string[][], colWidths: number[]) => {
    const rowHeight = 6;
    const headerHeight = 7;
    
    // Check if table fits, if not add page break
    const tableHeight = headerHeight + (rows.length * rowHeight);
    checkPageBreak(tableHeight + 5);
    
    // Draw headers
    pdf.setFillColor(230, 230, 230);
    pdf.rect(margin, yPosition, contentWidth, headerHeight, 'F');
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'bold');
    
    let xPos = margin + 2;
    headers.forEach((header, i) => {
      pdf.text(header, xPos, yPosition + 5);
      xPos += colWidths[i];
    });
    
    yPosition += headerHeight;
    
    // Draw rows
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(8);
    
    rows.forEach((row, rowIndex) => {
      if (checkPageBreak(rowHeight + 2)) {
        // Redraw headers on new page
        pdf.setFillColor(230, 230, 230);
        pdf.rect(margin, yPosition, contentWidth, headerHeight, 'F');
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'bold');
        xPos = margin + 2;
        headers.forEach((header, i) => {
          pdf.text(header, xPos, yPosition + 5);
          xPos += colWidths[i];
        });
        yPosition += headerHeight;
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(8);
      }
      
      // Alternate row colors
      if (rowIndex % 2 === 1) {
        pdf.setFillColor(248, 248, 248);
        pdf.rect(margin, yPosition, contentWidth, rowHeight, 'F');
      }
      
      xPos = margin + 2;
      row.forEach((cell, i) => {
        const align = i === 0 ? 'left' : 'right';
        if (align === 'right') {
          pdf.text(cell, xPos + colWidths[i] - 4, yPosition + 4, { align: 'right' });
        } else {
          pdf.text(cell, xPos, yPosition + 4);
        }
        xPos += colWidths[i];
      });
      
      yPosition += rowHeight;
    });
    
    yPosition += 5;
  };

  // ========== COVER PAGE ==========
  pdf.setFontSize(28);
  pdf.setFont('helvetica', 'bold');
  const reportTitle = reportType === 'ai-assisted' ? 'AI-Assisted Financial Report' : 'Comprehensive Financial Report';
  pdf.text(reportTitle, pageWidth / 2, 50, { align: 'center' });

  pdf.setFontSize(20);
  pdf.setFont('helvetica', 'normal');
  pdf.text(modelData.project_name || modelData.name, pageWidth / 2, 75, { align: 'center' });
  
  pdf.setFontSize(12);
  pdf.setTextColor(60, 60, 60);
  pdf.text(`Country: ${modelData.country || 'Not specified'}`, pageWidth / 2, 95, { align: 'center' });
  pdf.text(`Projection Period: ${modelData.start_year} - ${modelData.end_year}`, pageWidth / 2, 105, { align: 'center' });
  pdf.text(`Report Generated: ${new Date().toLocaleDateString()}`, pageWidth / 2, 115, { align: 'center' });
  pdf.setTextColor(0, 0, 0);

  addPageFooter();
  pdf.addPage();
  currentPage++;
  yPosition = margin;

  // ========== EXECUTIVE SUMMARY ==========
  addSectionTitle('Executive Summary');
  
  if (reportType === 'ai-assisted' && aiCommentary) {
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    const summaryHeight = addText(aiCommentary.executiveSummary, margin, yPosition, contentWidth, 10);
    yPosition += summaryHeight + 10;
  } else {
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`This report provides a comprehensive financial analysis for ${modelData.project_name || modelData.name}`, margin, yPosition);
    yPosition += 5;
    pdf.text(`over the ${modelData.end_year - modelData.start_year + 1}-year projection period from ${modelData.start_year} to ${modelData.end_year}.`, margin, yPosition);
    yPosition += 10;
  }

  // Key Metrics Dashboard
  if (comprehensiveMetrics) {
    checkPageBreak(50);
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Key Financial Metrics', margin, yPosition);
    yPosition += 8;
    
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'normal');
    const metricsData = [
      ['Equity NPV:', formatCurrency(comprehensiveMetrics.returns?.equity?.npv || 0)],
      ['Equity IRR:', formatPercent(comprehensiveMetrics.returns?.equity?.irr || 0)],
      ['Project NPV:', formatCurrency(comprehensiveMetrics.returns?.project?.npv || 0)],
      ['Project IRR:', formatPercent(comprehensiveMetrics.returns?.project?.irr || 0)],
      ['Payback Period:', `${(comprehensiveMetrics.returns?.equity?.payback || 0).toFixed(1)} years`],
      ['Min DSCR:', (comprehensiveMetrics.debt?.minDSCR || 0).toFixed(2)],
      ['Peak Funding:', formatCurrency(comprehensiveMetrics.liquidity?.peakFundingNeed || 0)],
    ];
    
    metricsData.forEach(([label, value]) => {
      pdf.setFont('helvetica', 'normal');
      pdf.text(label, margin + 5, yPosition);
      pdf.setFont('helvetica', 'bold');
      pdf.text(value, margin + 70, yPosition);
      yPosition += 6;
    });
    yPosition += 5;
  }

  // ========== MODEL INPUTS ==========
  if (modelInputs) {
    addSectionTitle('Model Inputs & Assumptions');
    
    // Operational Metrics
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Operational Metrics', margin, yPosition);
    yPosition += 7;
    
    const opHeaders = ['Year', 'Credits Generated', 'Price/Credit', 'Issuance'];
    const opColWidths = [25, 40, 40, 35];
    const opRows: string[][] = [];
    
    modelInputs.years.forEach((year: number, idx: number) => {
      opRows.push([
        year.toString(),
        (modelInputs.credits_generated?.[idx] || 0).toLocaleString(),
        formatCurrency(modelInputs.price_per_credit?.[idx] || 0),
        modelInputs.issuance_flag?.[idx] ? 'Yes' : 'No'
      ]);
    });
    
    addDataTable(opHeaders, opRows, opColWidths);
    
    // Expenses
    checkPageBreak(40);
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Annual Expenses', margin, yPosition);
    yPosition += 7;
    
    const expHeaders = ['Year', 'Feasibility', 'PDD', 'MRV', 'Staff', 'Depreciation', 'CAPEX'];
    const expColWidths = [20, 25, 25, 25, 25, 28, 32];
    const expRows: string[][] = [];
    
    modelInputs.years.forEach((year: number, idx: number) => {
      expRows.push([
        year.toString(),
        formatCurrency(Math.abs(modelInputs.feasibility_costs?.[idx] || 0)),
        formatCurrency(Math.abs(modelInputs.pdd_costs?.[idx] || 0)),
        formatCurrency(Math.abs(modelInputs.mrv_costs?.[idx] || 0)),
        formatCurrency(Math.abs(modelInputs.staff_costs?.[idx] || 0)),
        formatCurrency(Math.abs(modelInputs.depreciation?.[idx] || 0)),
        formatCurrency(Math.abs(modelInputs.capex?.[idx] || 0))
      ]);
    });
    
    addDataTable(expHeaders, expRows, expColWidths);
    
    // Rates & Financing Assumptions
    checkPageBreak(40);
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Rates & Financing Assumptions', margin, yPosition);
    yPosition += 7;
    
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'normal');
    const assumptions = [
      ['COGS Rate:', formatPercent(modelInputs.cogs_rate || 0)],
      ['Tax Rate:', formatPercent(modelInputs.income_tax_rate || 0)],
      ['AR Rate:', formatPercent(modelInputs.ar_rate || 0)],
      ['AP Rate:', formatPercent(modelInputs.ap_rate || 0)],
      ['Interest Rate:', formatPercent(modelInputs.interest_rate || 0)],
      ['Debt Duration:', `${modelInputs.debt_duration_years || 0} years`],
      ['Discount Rate:', formatPercent(modelInputs.discount_rate || 0)],
      ['Initial Equity (t0):', formatCurrency(modelInputs.initial_equity_t0 || 0)],
    ];
    
    assumptions.forEach(([label, value]) => {
      pdf.text(label, margin + 5, yPosition);
      pdf.setFont('helvetica', 'bold');
      pdf.text(value, margin + 70, yPosition);
      pdf.setFont('helvetica', 'normal');
      yPosition += 6;
    });
    yPosition += 10;
  }

  // ========== FINANCIAL STATEMENTS ==========
  if (financialData) {
    addSectionTitle('Financial Statements');
    
    // Income Statement
    if (financialData.incomeStatements && financialData.incomeStatements.length > 0) {
      pdf.setFontSize(11);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Income Statement', margin, yPosition);
      yPosition += 7;
      
      const years = financialData.incomeStatements.map((stmt: any) => stmt.year);
      const incHeaders = ['Line Item', ...years.map((y: number) => y.toString())];
      const incColWidth = Math.min(30, contentWidth / (years.length + 1));
      const incColWidths = [50, ...years.map(() => incColWidth)];
      
      const incRows: string[][] = [
        ['REVENUE', ...years.map(() => '')],
        ['Carbon credit revenue – spot market', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.spot_revenue || 0))],
        ['Carbon credit revenue – pre-purchase', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.pre_purchase_revenue || 0))],
        ['Total Revenue', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.total_revenue || 0))],
        ['', ...years.map(() => '')],
        ['Cost of goods sold', ...years.map(() => '')],
        ['COGS', ...financialData.incomeStatements.map((s: any) => formatCurrency(Math.abs(s.cogs || 0)))],
        ['Gross Profit', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.gross_profit || 0))],
        ['', ...years.map(() => '')],
        ['OPERATING EXPENSES', ...years.map(() => '')],
        ['Feasibility study costs', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.feasibility_costs || 0))],
        ['PDD development costs', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.pdd_costs || 0))],
        ['Monitoring, Reporting, and Verification (MRV) costs', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.mrv_costs || 0))],
        ['Staff costs', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.staff_costs || 0))],
        ['Total Operational cost', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.total_opex || 0))],
        ['', ...years.map(() => '')],
        ['EBITDA', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.ebitda || 0))],
        ['Depreciation', ...financialData.incomeStatements.map((s: any) => formatCurrency(Math.abs(s.depreciation || 0)))],
        ['Interest expense', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.interest_expense || 0))],
        ['Earnings Before Tax', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.ebt || 0))],
        ['Income Tax', ...financialData.incomeStatements.map((s: any) => formatCurrency(Math.abs(s.tax || 0)))],
        ['Net Income', ...financialData.incomeStatements.map((s: any) => formatCurrency(s.net_income || 0))],
      ];
      
      addDataTable(incHeaders, incRows, incColWidths);
    }
    
    // Balance Sheet
    if (financialData.balanceSheets && financialData.balanceSheets.length > 0) {
      checkPageBreak(50);
      pdf.setFontSize(11);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Balance Sheet', margin, yPosition);
      yPosition += 7;
      
      const years = financialData.balanceSheets.map((stmt: any) => stmt.year);
      const bsHeaders = ['Line Item', ...years.map((y: number) => y.toString())];
      const bsColWidth = Math.min(30, contentWidth / (years.length + 1));
      const bsColWidths = [50, ...years.map(() => bsColWidth)];
      
      const bsRows: string[][] = [
        ['ASSETS', ...years.map(() => '')],
        ['Current Assets', ...years.map(() => '')],
        ['Cash', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.cash || 0))],
        ['Accounts Receivable', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.accounts_receivable || 0))],
        ['Non-current Assets', ...years.map(() => '')],
        ['Property, Plant & Equipment, Net', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.ppe_net || 0))],
        ['TOTAL ASSETS', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.total_assets || 0))],
        ['', ...years.map(() => '')],
        ['LIABILITIES', ...years.map(() => '')],
        ['Current Liabilities', ...years.map(() => '')],
        ['Accounts Payable', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.accounts_payable || 0))],
        ['Long-term Liabilities', ...years.map(() => '')],
        ['Unearned Revenue', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.unearned_revenue || 0))],
        ['Debt', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.debt || 0))],
        ['TOTAL LIABILITIES', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.total_liabilities || 0))],
        ['', ...years.map(() => '')],
        ['EQUITY', ...years.map(() => '')],
        ['Retained earnings', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.retained_earnings || 0))],
        ['Contributed capital', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.contributed_capital || 0))],
        ['TOTAL EQUITY', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.equity || 0))],
        ['TOTAL LIABILITIES & EQUITY', ...financialData.balanceSheets.map((s: any) => formatCurrency(s.total_liabilities_equity || 0))],
        ['Balance Check (Assets - Liab & Equity)', ...financialData.balanceSheets.map((s: any) => {
          const diff = Math.abs((s.total_assets || 0) - (s.total_liabilities_equity || 0));
          return diff < 0.01 ? '✓ Balanced' : formatCurrency(diff);
        })],
      ];
      
      addDataTable(bsHeaders, bsRows, bsColWidths);
    }
    
    // Cash Flow Statement
    if (financialData.cashFlowStatements && financialData.cashFlowStatements.length > 0) {
      checkPageBreak(50);
      pdf.setFontSize(11);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Cash Flow Statement', margin, yPosition);
      yPosition += 7;
      
      const years = financialData.cashFlowStatements.map((stmt: any) => stmt.year);
      const cfHeaders = ['Line Item', ...years.map((y: number) => y.toString())];
      const cfColWidth = Math.min(30, contentWidth / (years.length + 1));
      const cfColWidths = [50, ...years.map(() => cfColWidth)];
      
      const cfRows: string[][] = [
        ['OPERATING ACTIVITIES', ...years.map(() => '')],
        ['Net Income', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.net_income || 0))],
        ['Depreciation', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.depreciation || 0))],
        ['Decrease in accounts receivable', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.change_ar || 0))],
        ['Increase in accounts payable', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.change_ap || 0))],
        ['Operating Cash Flow', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.cfo || 0))],
        ['', ...years.map(() => '')],
        ['INVESTING ACTIVITIES', ...years.map(() => '')],
        ['CAPEX', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.capex || 0))],
        ['Investing Cash Flow', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.cfi || 0))],
        ['', ...years.map(() => '')],
        ['FINANCING ACTIVITIES', ...years.map(() => '')],
        ['Debt financing', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.debt_draw || 0))],
        ['Debt repayments', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.debt_repay || 0))],
        ['Change in unearned revenue (prepurchase) account', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.change_unearned_revenue || 0))],
        ['Equity injection', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.equity_injection || 0))],
        ['Financing Cash Flow', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.cff || 0))],
        ['', ...years.map(() => '')],
        ['CASH POSITION', ...years.map(() => '')],
        ['Cash Start', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.cash_start || 0))],
        ['Net Change Cash', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.net_cash_change || 0))],
        ['Cash End', ...financialData.cashFlowStatements.map((s: any) => formatCurrency(s.cash_end || 0))],
      ];
      
      addDataTable(cfHeaders, cfRows, cfColWidths);
    }
    
    // Debt Schedule
    if (financialData.debtSchedule && financialData.debtSchedule.length > 0) {
      checkPageBreak(40);
      pdf.setFontSize(11);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Debt Schedule', margin, yPosition);
      yPosition += 7;
      
      const years = financialData.debtSchedule.map((stmt: any) => stmt.year);
      const debtHeaders = ['Line Item', ...years.map((y: number) => y.toString())];
      const debtColWidth = Math.min(30, contentWidth / (years.length + 1));
      const debtColWidths = [50, ...years.map(() => debtColWidth)];
      
      const debtRows: string[][] = [
        ['Beginning Balance', ...financialData.debtSchedule.map((s: any) => formatCurrency(s.beginning_balance || 0))],
        ['Draw', ...financialData.debtSchedule.map((s: any) => formatCurrency(s.draw || 0))],
        ['Principal Payment', ...financialData.debtSchedule.map((s: any) => formatCurrency(Math.abs(s.principal_payment || 0)))],
        ['Ending Balance', ...financialData.debtSchedule.map((s: any) => formatCurrency(s.ending_balance || 0))],
        ['Interest Expense', ...financialData.debtSchedule.map((s: any) => formatCurrency(Math.abs(s.interest_expense || 0)))],
        ['DSCR', ...financialData.debtSchedule.map((s: any) => (s.dscr || 0).toFixed(2))],
      ];
      
      addDataTable(debtHeaders, debtRows, debtColWidths);
    }
    
    // Carbon Stream
    if (financialData.carbonStream && financialData.carbonStream.length > 0) {
      checkPageBreak(40);
      pdf.setFontSize(11);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Carbon Stream', margin, yPosition);
      yPosition += 7;
      
      const years = financialData.carbonStream.map((stmt: any) => stmt.year);
      const carbonColWidth = Math.min(28, contentWidth / (years.length + 2));
      const carbonColWidths = [50, ...years.map(() => carbonColWidth), carbonColWidth];
      
      // Calculate totals for carbon stream
      const totalCreditsGenerated = financialData.carbonStream.reduce((sum: number, s: any) => sum + (s.credits_generated || 0), 0);
      const totalCreditsIssued = financialData.carbonStream.reduce((sum: number, s: any) => sum + (s.credits_issued || 0), 0);
      const totalPurchasedCredits = financialData.carbonStream.reduce((sum: number, s: any) => sum + (s.purchased_credits || 0), 0);
      const totalPurchaseAmount = financialData.carbonStream.reduce((sum: number, s: any) => sum + (s.purchase_amount || 0), 0);
      const impliedPurchasePrice = totalPurchasedCredits > 0 ? totalPurchaseAmount / totalPurchasedCredits : 0;
      
      // Calculate Investor IRR
      const investorCashFlows: number[] = [];
      financialData.carbonStream.forEach((s: any, idx: number) => {
        const purchaseAmount = s.purchase_amount || 0;
        const deliveredValue = (s.purchased_credits || 0) * (s.spot_price || 0);
        investorCashFlows.push(idx === 0 ? -purchaseAmount : deliveredValue);
      });
      
      const calculateIRR = (cfs: number[]): number => {
        const maxIter = 1000;
        const tol = 0.00001;
        let low = -0.99;
        let high = 10.0;
        
        for (let i = 0; i < maxIter; i++) {
          const mid = (low + high) / 2;
          const npv = cfs.reduce((sum, cf, t) => sum + cf / Math.pow(1 + mid, t), 0);
          
          if (Math.abs(npv) < tol) return mid;
          if (npv > 0) low = mid;
          else high = mid;
        }
        return 0;
      };
      
      const investorIRR = calculateIRR(investorCashFlows);
      
      const carbonRows: string[][] = [
        ['Percentage of credits purchased', ...financialData.carbonStream.map((s: any) => formatPercent(s.purchase_percent || 0)), '-'],
        ['Number of credits', ...financialData.carbonStream.map((s: any) => (s.purchased_credits || 0).toLocaleString()), totalPurchasedCredits.toLocaleString()],
        ['Purchase Amount', ...financialData.carbonStream.map((s: any) => formatCurrency(s.purchase_amount || 0)), formatCurrency(totalPurchaseAmount)],
        ['Purchased Credits', ...financialData.carbonStream.map((s: any) => (s.purchased_credits || 0).toLocaleString()), totalPurchasedCredits.toLocaleString()],
        ['Implied Purchase Price', ...financialData.carbonStream.map((s: any) => formatCurrency(impliedPurchasePrice)), formatCurrency(impliedPurchasePrice)],
        ['Investor Cash Flow', ...investorCashFlows.map((cf: number) => formatCurrency(cf)), formatCurrency(investorCashFlows.reduce((sum, cf) => sum + cf, 0))],
        ['Investor IRR', ...years.map(() => ''), formatPercent(investorIRR)],
      ];
      
      // Update headers to include Total column
      const carbonHeaders = ['Line Item', ...years.map((y: number) => y.toString()), 'Total'];
      
      addDataTable(carbonHeaders, carbonRows, carbonColWidths);
    }
    
    // Free Cash Flow
    if (financialData.freeCashFlow && financialData.freeCashFlow.length > 0) {
      checkPageBreak(40);
      pdf.setFontSize(11);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Free Cash Flow to Equity', margin, yPosition);
      yPosition += 7;
      
      const years = financialData.freeCashFlow.map((stmt: any) => stmt.year);
      const fcfHeaders = ['Line Item', ...years.map((y: number) => y.toString())];
      const fcfColWidth = Math.min(30, contentWidth / (years.length + 1));
      const fcfColWidths = [50, ...years.map(() => fcfColWidth)];
      
      const fcfRows: string[][] = [
        ['Net Income', ...financialData.freeCashFlow.map((s: any) => formatCurrency(s.net_income || 0))],
        ['Depreciation', ...financialData.freeCashFlow.map((s: any) => formatCurrency(s.depreciation || 0))],
        ['Change in NWC', ...financialData.freeCashFlow.map((s: any) => formatCurrency(s.change_nwc || 0))],
        ['CAPEX', ...financialData.freeCashFlow.map((s: any) => formatCurrency(s.capex || 0))],
        ['Net Borrowing', ...financialData.freeCashFlow.map((s: any) => formatCurrency(s.net_borrowing || 0))],
        ['FCF to Equity', ...financialData.freeCashFlow.map((s: any) => formatCurrency(s.fcf_equity || 0))],
      ];
      
      addDataTable(fcfHeaders, fcfRows, fcfColWidths);
    }
  }

  // ========== COMPREHENSIVE METRICS ==========
  if (comprehensiveMetrics) {
    addSectionTitle('Comprehensive Financial Metrics');
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Detailed breakdown of all financial metrics across the project lifetime', margin, yPosition);
    yPosition += 10;
    
    // Get years from metrics
    const metricsYears = comprehensiveMetrics.profitability?.yearly?.map((y: any) => y.year) || [];
    
    // 1. Returns & NPV Analysis
    if (comprehensiveMetrics.returns) {
      checkPageBreak(50);
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'bold');
      pdf.text('1. Returns & NPV Analysis', margin, yPosition);
      yPosition += 8;
      
      // Equity Returns
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Equity Returns (Levered)', margin + 5, yPosition);
      yPosition += 5;
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'italic');
      pdf.text('Returns to equity holders after debt service', margin + 5, yPosition);
      yPosition += 7;
      
      pdf.setFontSize(9);
      pdf.setFont('helvetica', 'normal');
      const equityReturns = [
        ['IRR:', comprehensiveMetrics.returns.equity?.irr ? formatPercent(comprehensiveMetrics.returns.equity.irr) : 'n/a'],
        ['NPV:', formatCurrency(comprehensiveMetrics.returns.equity?.npv || 0)],
        ['MIRR:', comprehensiveMetrics.returns.equity?.mirr ? formatPercent(comprehensiveMetrics.returns.equity.mirr) : 'n/a'],
        ['Payback:', comprehensiveMetrics.returns.equity?.payback ? `${comprehensiveMetrics.returns.equity.payback.toFixed(1)} years` : '> horizon'],
        ['Discounted Payback:', comprehensiveMetrics.returns.equity?.discountedPayback ? `${comprehensiveMetrics.returns.equity.discountedPayback.toFixed(1)} years` : '> horizon'],
      ];
      
      equityReturns.forEach(([label, value]) => {
        checkPageBreak(6);
        pdf.text(label, margin + 10, yPosition);
        pdf.setFont('helvetica', 'bold');
        pdf.text(value, margin + 80, yPosition);
        pdf.setFont('helvetica', 'normal');
        yPosition += 6;
      });
      yPosition += 5;
      
      // Project Returns
      checkPageBreak(35);
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Project Returns (Unlevered)', margin + 5, yPosition);
      yPosition += 5;
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'italic');
      pdf.text('Returns before financing considerations', margin + 5, yPosition);
      yPosition += 7;
      
      pdf.setFontSize(9);
      pdf.setFont('helvetica', 'normal');
      const projectReturns = [
        ['IRR:', comprehensiveMetrics.returns.project?.irr ? formatPercent(comprehensiveMetrics.returns.project.irr) : 'n/a'],
        ['NPV:', formatCurrency(comprehensiveMetrics.returns.project?.npv || 0)],
        ['MIRR:', comprehensiveMetrics.returns.project?.mirr ? formatPercent(comprehensiveMetrics.returns.project.mirr) : 'n/a'],
        ['Payback:', comprehensiveMetrics.returns.project?.payback ? `${comprehensiveMetrics.returns.project.payback.toFixed(1)} years` : '> horizon'],
        ['Discounted Payback:', comprehensiveMetrics.returns.project?.discountedPayback ? `${comprehensiveMetrics.returns.project.discountedPayback.toFixed(1)} years` : '> horizon'],
      ];
      
      projectReturns.forEach(([label, value]) => {
        checkPageBreak(6);
        pdf.text(label, margin + 10, yPosition);
        pdf.setFont('helvetica', 'bold');
        pdf.text(value, margin + 80, yPosition);
        pdf.setFont('helvetica', 'normal');
        yPosition += 6;
      });
      yPosition += 5;
      
      // Investor Returns
      if (comprehensiveMetrics.returns.investor) {
        checkPageBreak(20);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'bold');
        pdf.text('Investor Returns (Pre-purchase)', margin + 5, yPosition);
        yPosition += 5;
        pdf.setFontSize(8);
        pdf.setFont('helvetica', 'italic');
        pdf.text('Returns to carbon stream investor', margin + 5, yPosition);
        yPosition += 7;
        
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'normal');
        const investorReturns = [
          ['IRR:', comprehensiveMetrics.returns.investor?.irr ? formatPercent(comprehensiveMetrics.returns.investor.irr) : 'n/a'],
          ['NPV:', formatCurrency(comprehensiveMetrics.returns.investor?.npv || 0)],
        ];
        
        investorReturns.forEach(([label, value]) => {
          checkPageBreak(6);
          pdf.text(label, margin + 10, yPosition);
          pdf.setFont('helvetica', 'bold');
          pdf.text(value, margin + 80, yPosition);
          pdf.setFont('helvetica', 'normal');
          yPosition += 6;
        });
        yPosition += 10;
      }
    }
    
    // 2. Profitability & Margins
    if (comprehensiveMetrics.profitability?.yearly && comprehensiveMetrics.profitability.yearly.length > 0) {
      checkPageBreak(60);
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'bold');
      pdf.text('2. Profitability & Margins', margin, yPosition);
      yPosition += 8;
      
      pdf.setFontSize(10);
      pdf.text('Income Statement Metrics by Year', margin + 5, yPosition);
      yPosition += 5;
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'italic');
      pdf.text('Revenue, costs, and profitability breakdown', margin + 5, yPosition);
      yPosition += 7;
      
      const profYears = comprehensiveMetrics.profitability.yearly.map((y: any) => y.year);
      const profHeaders = ['Metric', ...profYears.map((y: number) => y.toString()), 'Total'];
      const profColWidth = Math.min(25, (contentWidth - 50) / (profYears.length + 1));
      const profColWidths = [50, ...profYears.map(() => profColWidth), profColWidth];
      
      const totalRevenue = comprehensiveMetrics.profitability.yearly.reduce((sum: number, y: any) => sum + (y.revenue || 0), 0);
      const totalCOGS = comprehensiveMetrics.profitability.yearly.reduce((sum: number, y: any) => sum + (y.cogs || 0), 0);
      const totalOPEX = comprehensiveMetrics.profitability.yearly.reduce((sum: number, y: any) => sum + (y.opex || 0), 0);
      const totalEBITDA = comprehensiveMetrics.profitability.yearly.reduce((sum: number, y: any) => sum + (y.ebitda || 0), 0);
      const totalDepreciation = comprehensiveMetrics.profitability.yearly.reduce((sum: number, y: any) => sum + (y.depreciation || 0), 0);
      const totalInterest = comprehensiveMetrics.profitability.yearly.reduce((sum: number, y: any) => sum + (y.interest || 0), 0);
      const totalTax = comprehensiveMetrics.profitability.yearly.reduce((sum: number, y: any) => sum + (y.tax || 0), 0);
      const totalNetIncome = comprehensiveMetrics.profitability.yearly.reduce((sum: number, y: any) => sum + (y.netIncome || 0), 0);
      
      const profRows: string[][] = [
        ['Revenue', ...comprehensiveMetrics.profitability.yearly.map((y: any) => formatCurrency(y.revenue || 0)), formatCurrency(totalRevenue)],
        ['COGS', ...comprehensiveMetrics.profitability.yearly.map((y: any) => formatCurrency(y.cogs || 0)), formatCurrency(totalCOGS)],
        ['Gross Profit', ...comprehensiveMetrics.profitability.yearly.map((y: any) => formatCurrency((y.revenue || 0) - (y.cogs || 0))), formatCurrency(totalRevenue - totalCOGS)],
        ['OPEX', ...comprehensiveMetrics.profitability.yearly.map((y: any) => formatCurrency(y.opex || 0)), formatCurrency(totalOPEX)],
        ['EBITDA', ...comprehensiveMetrics.profitability.yearly.map((y: any) => formatCurrency(y.ebitda || 0)), formatCurrency(totalEBITDA)],
        ['Depreciation', ...comprehensiveMetrics.profitability.yearly.map((y: any) => formatCurrency(y.depreciation || 0)), formatCurrency(totalDepreciation)],
        ['Interest', ...comprehensiveMetrics.profitability.yearly.map((y: any) => formatCurrency(y.interest || 0)), formatCurrency(totalInterest)],
        ['EBT', ...comprehensiveMetrics.profitability.yearly.map((y: any) => formatCurrency((y.ebitda || 0) - (y.depreciation || 0) - (y.interest || 0))), ''],
        ['Tax', ...comprehensiveMetrics.profitability.yearly.map((y: any) => formatCurrency(y.tax || 0)), formatCurrency(totalTax)],
        ['Net Income', ...comprehensiveMetrics.profitability.yearly.map((y: any) => formatCurrency(y.netIncome || 0)), formatCurrency(totalNetIncome)],
        ['Gross Margin %', ...comprehensiveMetrics.profitability.yearly.map((y: any) => y.revenue ? formatPercent((y.revenue - y.cogs) / y.revenue) : '–'), ''],
        ['EBITDA Margin %', ...comprehensiveMetrics.profitability.yearly.map((y: any) => y.revenue ? formatPercent(y.ebitda / y.revenue) : '–'), ''],
        ['Net Margin %', ...comprehensiveMetrics.profitability.yearly.map((y: any) => y.revenue ? formatPercent(y.netIncome / y.revenue) : '–'), ''],
      ];
      
      addDataTable(profHeaders, profRows, profColWidths);
    }
    
    // 3. Unit Economics
    if (comprehensiveMetrics.unitEconomics?.yearly && comprehensiveMetrics.unitEconomics.yearly.length > 0) {
      checkPageBreak(60);
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'bold');
      pdf.text('3. Unit Economics', margin, yPosition);
      yPosition += 8;
      
      // Per Credit Economics
      pdf.setFontSize(10);
      pdf.text('Per Credit Economics', margin + 5, yPosition);
      yPosition += 5;
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'italic');
      pdf.text('Cost and revenue per issued carbon credit', margin + 5, yPosition);
      yPosition += 7;
      
      const unitYears = comprehensiveMetrics.unitEconomics.yearly.map((y: any) => y.year);
      const unitHeaders = ['Metric', ...unitYears.map((y: number) => y.toString()), 'Average'];
      const unitColWidth = Math.min(25, (contentWidth - 50) / (unitYears.length + 1));
      const unitColWidths = [50, ...unitYears.map(() => unitColWidth), unitColWidth];
      
      const avgIssuedCredits = comprehensiveMetrics.unitEconomics.yearly.reduce((sum: number, y: any) => sum + (y.issuedCredits || 0), 0);
      const avgPrice = comprehensiveMetrics.unitEconomics.avgPricePerCredit || 0;
      const avgCOGS = comprehensiveMetrics.unitEconomics.avgCogsPerCredit || 0;
      const avgLCOC = comprehensiveMetrics.unitEconomics.lcoc || 0;
      
      const unitRows: string[][] = [
        ['Issued Credits', ...comprehensiveMetrics.unitEconomics.yearly.map((y: any) => (y.issuedCredits || 0).toLocaleString()), avgIssuedCredits.toLocaleString()],
        ['WA Price', ...comprehensiveMetrics.unitEconomics.yearly.map((y: any) => formatCurrency(y.pricePerCredit || 0)), formatCurrency(avgPrice)],
        ['COGS/Credit', ...comprehensiveMetrics.unitEconomics.yearly.map((y: any) => formatCurrency(y.cogsPerCredit || 0)), formatCurrency(avgCOGS)],
        ['GP/Credit', ...comprehensiveMetrics.unitEconomics.yearly.map((y: any) => formatCurrency((y.pricePerCredit || 0) - (y.cogsPerCredit || 0))), ''],
        ['OPEX/Credit', ...comprehensiveMetrics.unitEconomics.yearly.map((y: any) => formatCurrency(y.opexPerCredit || 0)), ''],
        ['LCOC', ...comprehensiveMetrics.unitEconomics.yearly.map((y: any) => formatCurrency(y.lcoc || 0)), formatCurrency(avgLCOC)],
        ['All-in Cost', ...comprehensiveMetrics.unitEconomics.yearly.map((y: any) => formatCurrency((y.cogsPerCredit || 0) + (y.opexPerCredit || 0))), ''],
      ];
      
      addDataTable(unitHeaders, unitRows, unitColWidths);
      
      // Break-even Analysis
      if (comprehensiveMetrics.breakEven?.yearly && comprehensiveMetrics.breakEven.yearly.length > 0) {
        checkPageBreak(40);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'bold');
        pdf.text('Break-even Analysis', margin + 5, yPosition);
        yPosition += 5;
        pdf.setFontSize(8);
        pdf.setFont('helvetica', 'italic');
        pdf.text('Price and volume thresholds for profitability', margin + 5, yPosition);
        yPosition += 7;
        
        const beYears = comprehensiveMetrics.breakEven.yearly.map((y: any) => y.year);
        const beHeaders = ['Metric', ...beYears.map((y: number) => y.toString())];
        const beColWidth = Math.min(28, (contentWidth - 50) / beYears.length);
        const beColWidths = [50, ...beYears.map(() => beColWidth)];
        
        const beRows: string[][] = [
          ['BE Price (Oper)', ...comprehensiveMetrics.breakEven.yearly.map((y: any) => formatCurrency(y.breakEvenPrice || 0))],
          ['Realized Price', ...comprehensiveMetrics.breakEven.yearly.map((y: any) => formatCurrency(y.realizedPrice || 0))],
          ['Safety Spread', ...comprehensiveMetrics.breakEven.yearly.map((y: any) => formatCurrency((y.realizedPrice || 0) - (y.breakEvenPrice || 0)))],
          ['BE Volume', ...comprehensiveMetrics.breakEven.yearly.map((y: any) => y.breakEvenVolume ? (y.breakEvenVolume).toLocaleString() : '–')],
        ];
        
        addDataTable(beHeaders, beRows, beColWidths);
      }
    }
    
    // 4. Working Capital Management
    if (comprehensiveMetrics.workingCapital?.yearly && comprehensiveMetrics.workingCapital.yearly.length > 0) {
      checkPageBreak(50);
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'bold');
      pdf.text('4. Working Capital Management', margin, yPosition);
      yPosition += 8;
      
      pdf.setFontSize(10);
      pdf.text('AR, AP, and Cash Conversion Metrics', margin + 5, yPosition);
      yPosition += 5;
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'italic');
      pdf.text('Working capital efficiency by year', margin + 5, yPosition);
      yPosition += 7;
      
      const wcYears = comprehensiveMetrics.workingCapital.yearly.map((y: any) => y.year);
      const wcHeaders = ['Metric', ...wcYears.map((y: number) => y.toString())];
      const wcColWidth = Math.min(28, (contentWidth - 50) / wcYears.length);
      const wcColWidths = [50, ...wcYears.map(() => wcColWidth)];
      
      const wcRows: string[][] = [
        ['AR', ...comprehensiveMetrics.workingCapital.yearly.map((y: any) => formatCurrency(y.ar || 0))],
        ['AP', ...comprehensiveMetrics.workingCapital.yearly.map((y: any) => formatCurrency(y.ap || 0))],
        ['NWC', ...comprehensiveMetrics.workingCapital.yearly.map((y: any) => formatCurrency(y.nwc || 0))],
        ['Revenue', ...comprehensiveMetrics.workingCapital.yearly.map((y: any) => formatCurrency(y.revenue || 0))],
        ['DSO (days)', ...comprehensiveMetrics.workingCapital.yearly.map((y: any) => y.dso ? Math.round(y.dso).toString() : '–')],
        ['DPO (days)', ...comprehensiveMetrics.workingCapital.yearly.map((y: any) => y.dpo ? Math.round(y.dpo).toString() : '–')],
        ['NWC % Rev', ...comprehensiveMetrics.workingCapital.yearly.map((y: any) => y.nwcToRevenue ? formatPercent(y.nwcToRevenue) : '–')],
      ];
      
      addDataTable(wcHeaders, wcRows, wcColWidths);
    }
    
    // 5. Liquidity & Debt
    if (comprehensiveMetrics.liquidity?.yearly && comprehensiveMetrics.liquidity.yearly.length > 0) {
      checkPageBreak(60);
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'bold');
      pdf.text('5. Liquidity & Debt', margin, yPosition);
      yPosition += 8;
      
      // Liquidity Ratios
      pdf.setFontSize(10);
      pdf.text('Liquidity Ratios', margin + 5, yPosition);
      yPosition += 5;
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'italic');
      pdf.text('Balance sheet health and solvency metrics', margin + 5, yPosition);
      yPosition += 7;
      
      const liqYears = comprehensiveMetrics.liquidity.yearly.map((y: any) => y.year);
      const liqHeaders = ['Metric', ...liqYears.map((y: number) => y.toString())];
      const liqColWidth = Math.min(28, (contentWidth - 50) / liqYears.length);
      const liqColWidths = [50, ...liqYears.map(() => liqColWidth)];
      
      const liqRows: string[][] = [
        ['Cash', ...comprehensiveMetrics.liquidity.yearly.map((y: any) => formatCurrency(y.cash || 0))],
        ['Current Ratio', ...comprehensiveMetrics.liquidity.yearly.map((y: any) => y.currentRatio ? y.currentRatio.toFixed(2) : '–')],
        ['Cash Ratio', ...comprehensiveMetrics.liquidity.yearly.map((y: any) => y.cashRatio ? y.cashRatio.toFixed(2) : '–')],
        ['D/E', ...comprehensiveMetrics.liquidity.yearly.map((y: any) => y.debtToEquity ? y.debtToEquity.toFixed(2) : '–')],
        ['Net Debt/EBITDA', ...comprehensiveMetrics.liquidity.yearly.map((y: any) => y.netDebtToEbitda ? y.netDebtToEbitda.toFixed(2) : '–')],
        ['Interest Coverage', ...comprehensiveMetrics.liquidity.yearly.map((y: any) => y.interestCoverage ? y.interestCoverage.toFixed(2) : '–')],
      ];
      
      addDataTable(liqHeaders, liqRows, liqColWidths);
      
      // Debt Service & Coverage
      if (comprehensiveMetrics.debt?.yearly && comprehensiveMetrics.debt.yearly.length > 0) {
        checkPageBreak(40);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'bold');
        pdf.text('Debt Service & Coverage', margin + 5, yPosition);
        yPosition += 5;
        pdf.setFontSize(8);
        pdf.setFont('helvetica', 'italic');
        pdf.text('Debt schedule and DSCR by year', margin + 5, yPosition);
        yPosition += 7;
        
        const debtYears = comprehensiveMetrics.debt.yearly.map((y: any) => y.year);
        const debtHeaders = ['Metric', ...debtYears.map((y: number) => y.toString())];
        const debtColWidth = Math.min(28, (contentWidth - 50) / debtYears.length);
        const debtColWidths = [50, ...debtYears.map(() => debtColWidth)];
        
        const debtRows: string[][] = [
          ['Beg Balance', ...comprehensiveMetrics.debt.yearly.map((y: any) => formatCurrency(y.beginningBalance || 0))],
          ['Draw', ...comprehensiveMetrics.debt.yearly.map((y: any) => formatCurrency(y.draw || 0))],
          ['Principal', ...comprehensiveMetrics.debt.yearly.map((y: any) => formatCurrency(y.principal || 0))],
          ['End Balance', ...comprehensiveMetrics.debt.yearly.map((y: any) => formatCurrency(y.endingBalance || 0))],
          ['Interest', ...comprehensiveMetrics.debt.yearly.map((y: any) => formatCurrency(y.interest || 0))],
          ['DSCR', ...comprehensiveMetrics.debt.yearly.map((y: any) => y.dscr ? `${y.dscr.toFixed(2)}x` : '–x')],
        ];
        
        addDataTable(debtHeaders, debtRows, debtColWidths);
      }
    }
    
    // 6. Carbon KPIs
    if (comprehensiveMetrics.carbonKPIs?.yearly && comprehensiveMetrics.carbonKPIs.yearly.length > 0) {
      checkPageBreak(50);
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'bold');
      pdf.text('6. Carbon KPIs', margin, yPosition);
      yPosition += 8;
      
      pdf.setFontSize(10);
      pdf.text('Carbon Credit Metrics', margin + 5, yPosition);
      yPosition += 5;
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'italic');
      pdf.text('Generation, issuance, and pricing by year', margin + 5, yPosition);
      yPosition += 7;
      
      const carbonYears = comprehensiveMetrics.carbonKPIs.yearly.map((y: any) => y.year);
      const carbonHeaders = ['Metric', ...carbonYears.map((y: number) => y.toString()), 'Total'];
      const carbonColWidth = Math.min(25, (contentWidth - 50) / (carbonYears.length + 1));
      const carbonColWidths = [50, ...carbonYears.map(() => carbonColWidth), carbonColWidth];
      
      const totalGenerated = comprehensiveMetrics.carbonKPIs.yearly.reduce((sum: number, y: any) => sum + (y.creditsGenerated || 0), 0);
      const totalIssued = comprehensiveMetrics.carbonKPIs.yearly.reduce((sum: number, y: any) => sum + (y.creditsIssued || 0), 0);
      const totalDelivered = comprehensiveMetrics.carbonKPIs.yearly.reduce((sum: number, y: any) => sum + (y.ppDelivered || 0), 0);
      
      const carbonRows: string[][] = [
        ['Generated', ...comprehensiveMetrics.carbonKPIs.yearly.map((y: any) => (y.creditsGenerated || 0).toLocaleString()), totalGenerated.toLocaleString()],
        ['Issued', ...comprehensiveMetrics.carbonKPIs.yearly.map((y: any) => (y.creditsIssued || 0).toLocaleString()), totalIssued.toLocaleString()],
        ['Issuance %', ...comprehensiveMetrics.carbonKPIs.yearly.map((y: any) => y.issuanceRate ? formatPercent(y.issuanceRate) : '0%'), ''],
        ['PP Delivered', ...comprehensiveMetrics.carbonKPIs.yearly.map((y: any) => (y.ppDelivered || 0).toLocaleString()), totalDelivered.toLocaleString()],
        ['PP Remaining', ...comprehensiveMetrics.carbonKPIs.yearly.map((y: any) => y.ppRemaining ? (y.ppRemaining).toLocaleString() : '–'), ''],
        ['WA Price', ...comprehensiveMetrics.carbonKPIs.yearly.map((y: any) => formatCurrency(y.waPrice || 0)), ''],
        ['Spot Price', ...comprehensiveMetrics.carbonKPIs.yearly.map((y: any) => formatCurrency(y.spotPrice || 0)), ''],
      ];
      
      addDataTable(carbonHeaders, carbonRows, carbonColWidths);
    }
    
    // 7. Financial Charts (section title only, charts added later)
    checkPageBreak(15);
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'bold');
    pdf.text('7. Financial Charts & Visualizations', margin, yPosition);
    yPosition += 8;
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'italic');
    pdf.text('Visual representations of key trends and metrics (see Charts & Visualizations section)', margin + 5, yPosition);
    yPosition += 10;
  }

  // ========== SCENARIO ANALYSIS ==========
  if (scenarios && scenarios.length > 0) {
    addSectionTitle('Scenario Analysis');
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`${scenarios.length} scenario(s) analyzed`, margin, yPosition);
    yPosition += 10;
    
    scenarios.forEach((scenario, index) => {
      checkPageBreak(40);
      
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'bold');
      const scenarioTitle = `${index + 1}. ${scenario.scenario_name}${scenario.is_base_case ? ' (Base Case)' : ''}`;
      pdf.text(scenarioTitle, margin, yPosition);
      yPosition += 7;
      
      if (scenario.probability) {
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'normal');
        pdf.text(`Probability: ${formatPercent(scenario.probability)}`, margin + 5, yPosition);
        yPosition += 6;
      }
      
      // Key metrics for scenario
      if (scenario.metrics) {
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'normal');
        const scenMetrics = [
          ['Equity NPV:', formatCurrency(scenario.metrics.returns?.equity?.npv || 0)],
          ['Equity IRR:', formatPercent(scenario.metrics.returns?.equity?.irr || 0)],
          ['Project NPV:', formatCurrency(scenario.metrics.returns?.project?.npv || 0)],
        ];
        
        scenMetrics.forEach(([label, value]) => {
          checkPageBreak(7);
          pdf.text(label, margin + 5, yPosition);
          pdf.setFont('helvetica', 'bold');
          pdf.text(value, margin + 50, yPosition);
          pdf.setFont('helvetica', 'normal');
          yPosition += 6;
        });
      }
      
      // Variable changes
      if (scenario.changes && scenario.changes.length > 0) {
        checkPageBreak(20);
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'bold');
        pdf.text(`Variables Changed: ${scenario.changes.length}`, margin + 5, yPosition);
        yPosition += 7;
        
        scenario.changes.forEach((change) => {
          checkPageBreak(10);
          pdf.setFontSize(8);
          pdf.setFont('helvetica', 'bold');
          pdf.text(change.name, margin + 10, yPosition);
          yPosition += 5;
          
          pdf.setFont('helvetica', 'normal');
          const changeSign = change.change >= 0 ? '+' : '';
          pdf.text(`${formatVariableValue(change.key, change.baseValue)} → ${formatVariableValue(change.key, change.newValue)}  (${changeSign}${(change.change * 100).toFixed(1)}%)`, margin + 15, yPosition);
          yPosition += 6;
        });
        yPosition += 3;
      }
      
      // Impact Summary (show percentage change from base case)
      const baseCase = scenarios.find(s => s.is_base_case);
      if (!scenario.is_base_case && baseCase && scenario.metrics && baseCase.metrics) {
        checkPageBreak(20);
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'bold');
        pdf.text('Impact Summary:', margin + 5, yPosition);
        yPosition += 7;
        
        pdf.setFont('helvetica', 'normal');
        const baseNPV = baseCase.metrics.returns?.equity?.npv || 0;
        const scenarioNPV = scenario.metrics.returns?.equity?.npv || 0;
        const npvChange = baseNPV !== 0 ? ((scenarioNPV - baseNPV) / Math.abs(baseNPV)) * 100 : 0;
        
        const baseIRR = baseCase.metrics.returns?.equity?.irr || 0;
        const scenarioIRR = scenario.metrics.returns?.equity?.irr || 0;
        const irrChange = baseIRR !== 0 ? ((scenarioIRR - baseIRR) / Math.abs(baseIRR)) * 100 : 0;
        
        const baseRevenue = baseCase.metrics.profitability?.totalRevenue || 0;
        const scenarioRevenue = scenario.metrics.profitability?.totalRevenue || 0;
        const revenueChange = baseRevenue !== 0 ? ((scenarioRevenue - baseRevenue) / Math.abs(baseRevenue)) * 100 : 0;
        
        const impactData = [
          ['NPV:', `${npvChange >= 0 ? '+' : ''}${npvChange.toFixed(1)}%`],
          ['IRR:', `${irrChange >= 0 ? '+' : ''}${irrChange.toFixed(1)}%`],
          ['Revenue:', `${revenueChange >= 0 ? '+' : ''}${revenueChange.toFixed(1)}%`],
        ];
        
        impactData.forEach(([label, value]) => {
          checkPageBreak(6);
          pdf.text(label, margin + 10, yPosition);
          pdf.setFont('helvetica', 'bold');
          pdf.text(value, margin + 50, yPosition);
          pdf.setFont('helvetica', 'normal');
          yPosition += 6;
        });
        yPosition += 3;
      }
      
      // Notes
      if (scenario.notes) {
        checkPageBreak(15);
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'italic');
        pdf.text('Notes:', margin + 5, yPosition);
        yPosition += 6;
        pdf.setFont('helvetica', 'normal');
        const notesHeight = addText(scenario.notes, margin + 10, yPosition, contentWidth - 10, 9);
        yPosition += notesHeight + 5;
      }
      
      yPosition += 5;
    });
    
    // Probability-weighted metrics
    const withProbabilities = scenarios.filter(s => s.probability && s.probability > 0);
    if (withProbabilities.length > 0) {
      checkPageBreak(30);
      pdf.setFontSize(11);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Probability-Weighted Metrics', margin, yPosition);
      yPosition += 7;
      
      const totalProb = withProbabilities.reduce((sum, s) => sum + (s.probability || 0), 0);
      const weightedEquityNPV = withProbabilities.reduce((sum, s) => sum + (s.metrics?.returns?.equity?.npv || 0) * (s.probability || 0), 0);
      const weightedEquityIRR = withProbabilities.reduce((sum, s) => sum + (s.metrics?.returns?.equity?.irr || 0) * (s.probability || 0), 0);
      
      pdf.setFontSize(9);
      pdf.setFont('helvetica', 'normal');
      pdf.text(`Total Probability: ${formatPercent(totalProb)}`, margin + 5, yPosition);
      yPosition += 6;
      pdf.text('Weighted Equity NPV:', margin + 5, yPosition);
      pdf.setFont('helvetica', 'bold');
      pdf.text(formatCurrency(weightedEquityNPV), margin + 70, yPosition);
      yPosition += 6;
      pdf.setFont('helvetica', 'normal');
      pdf.text('Weighted Equity IRR:', margin + 5, yPosition);
      pdf.setFont('helvetica', 'bold');
      pdf.text(formatPercent(weightedEquityIRR), margin + 70, yPosition);
      yPosition += 10;
    }
  }

  // ========== CHARTS & VISUALIZATIONS ==========
  addSectionTitle('Charts & Visualizations');
  
  // Helper function to capture chart as image using dynamic import
  const captureChartAsImage = async (elementId: string): Promise<string | null> => {
    try {
      const element = document.getElementById(elementId);
      if (!element) {
        console.warn(`Chart element not found: ${elementId}`);
        return null;
      }

      // Wait for chart to fully render
      await new Promise(resolve => setTimeout(resolve, 100));

      // Dynamic import to avoid build-time issues
      const html2canvas = (await import('html2canvas')).default;
      
      const canvas = await html2canvas(element, {
        scale: 2,
        useCORS: true,
        backgroundColor: '#ffffff',
        logging: false,
      });

      return canvas.toDataURL('image/png');
    } catch (error) {
      console.error(`Error capturing chart ${elementId}:`, error);
      return null;
    }
  };

  // Wait a bit before starting chart capture to ensure full render
  await new Promise(resolve => setTimeout(resolve, 500));

  // Define charts to capture
  const charts = [
    { id: 'chart-revenue', title: 'Revenue by Source', description: 'Spot vs pre-purchase revenue breakdown' },
    { id: 'chart-profitability', title: 'Profitability Trend', description: 'EBITDA and Net Income over time' },
    { id: 'chart-cash', title: 'Cash Position', description: 'Cash balance trajectory' },
    { id: 'chart-dscr', title: 'Debt Service Coverage Ratio', description: 'DSCR with covenant threshold' },
    { id: 'chart-npv', title: 'Cumulative NPV', description: 'Net present value build-up by year' },
    { id: 'chart-prices', title: 'Price Comparison', description: 'Realized vs break-even pricing' }
  ];

  let chartsCaptured = 0;
  let chartsFailed = 0;

  for (const chart of charts) {
    try {
      const imageData = await captureChartAsImage(chart.id);
      
      if (imageData) {
        // Add page break if needed (2 charts per page)
        if (chartsCaptured > 0 && chartsCaptured % 2 === 0) {
          addPageFooter();
          pdf.addPage();
          currentPage++;
          yPosition = margin;
        } else if (chartsCaptured > 0) {
          yPosition += 10; // Space between charts on same page
        }

        checkPageBreak(120);
        
        // Add chart title
        pdf.setFontSize(12);
        pdf.setFont('helvetica', 'bold');
        pdf.text(chart.title, margin, yPosition);
        yPosition += 5;
        
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'italic');
        pdf.setTextColor(100, 100, 100);
        pdf.text(chart.description, margin, yPosition);
        pdf.setTextColor(0, 0, 0);
        yPosition += 8;
        
        // Add chart image
        const imgWidth = contentWidth;
        const imgHeight = 100; // Fixed height for consistency
        pdf.addImage(imageData, 'PNG', margin, yPosition, imgWidth, imgHeight);
        yPosition += imgHeight + 5;
        
        chartsCaptured++;
      } else {
        chartsFailed++;
      }
    } catch (error) {
      console.error(`Failed to add chart ${chart.id}:`, error);
      chartsFailed++;
    }
  }

  // Add note if some charts failed
  if (chartsFailed > 0) {
    checkPageBreak(15);
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'italic');
    pdf.setTextColor(100, 100, 100);
    pdf.text(`Note: ${chartsFailed} chart(s) could not be captured. View the online report for all visualizations.`, margin, yPosition);
    pdf.setTextColor(0, 0, 0);
    yPosition += 10;
  }

  pdf.setFont('helvetica', 'normal');

  // ========== AI COMMENTARY (AI-assisted reports only) ==========
  if (reportType === 'ai-assisted' && aiCommentary) {
    addSectionTitle('Risk Assessment');
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    const riskHeight = addText(aiCommentary.riskAssessment, margin, yPosition, contentWidth, 10);
    yPosition += riskHeight + 10;
    
    addSectionTitle('Scenario Commentary');
    const scenarioHeight = addText(aiCommentary.scenarioCommentary, margin, yPosition, contentWidth, 10);
    yPosition += scenarioHeight + 10;
    
    addSectionTitle('Investment Highlights');
    const highlightsHeight = addText(aiCommentary.investorHighlights, margin, yPosition, contentWidth, 10);
    yPosition += highlightsHeight + 10;
  }

  // Footer on last page
  const totalPages = pdf.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    pdf.setPage(i);
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin, pageHeight - 10, { align: 'right' });
    pdf.text('Generated by Financial Platform', margin, pageHeight - 10);
  }

  // Save the PDF
  const fileName = `${modelData.project_name || modelData.name}_${reportType}_report_${new Date().toISOString().split('T')[0]}.pdf`;
  pdf.save(fileName);
};